<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reviewer</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
</head>
<body class="apps-page reviewer-page">
  <a href="apps.html" class="apps-button back-button">Apps</a>

  <div class="container reviewer-container">
    <h1>Reviewer</h1>
    <p class="apps-intro reviewer-intro">
      Summon a focused study guide powered by Google Gemini. Describe a topic, pick how many Q&A items you want, review the summaries, then challenge yourself with a randomized quiz.
    </p>

    <section class="reviewer-form" role="form" aria-label="Generate AI reviewer">
      <div class="form-field">
        <label for="topicInput">What do you want to study?</label>
        <textarea id="topicInput" rows="3" placeholder="e.g., Medical study about feet, Philippine history on EDSA Revolution" required></textarea>
      </div>

      <div class="form-field">
        <label for="pdfInput">Attach a PDF (optional)</label>
        <p class="field-hint">Upload lecture notes, reviewers, or any PDF under 10&nbsp;MB. We'll extract the text locally and include the highlights in your prompt.</p>
        <input id="pdfInput" type="file" accept="application/pdf" />
        <div class="pdf-status" id="pdfStatus" hidden>
          <div>
            <p id="pdfStatusText"></p>
            <p class="field-hint" id="pdfMetaText"></p>
          </div>
          <button type="button" id="clearPdfBtn" class="ghost-button btn-compact">Remove PDF</button>
        </div>
        <div class="pdf-options" id="pdfOptions" hidden>
          <label class="checkbox-inline">
            <input type="checkbox" id="includePdfToggle" checked />
            <span>Blend uploaded PDF text with my prompt</span>
          </label>
          <p class="field-hint">Gemini will receive both your typed topic and a condensed excerpt from the PDF.</p>
        </div>
      </div>

      <div class="form-field">
        <label for="questionPreset">How many questions?</label>
        <div class="count-control">
          <select id="questionPreset">
            <option value="10">10 questions</option>
            <option value="20">20 questions</option>
            <option value="30">30 questions</option>
            <option value="40">40 questions</option>
            <option value="50">50 questions</option>
            <option value="custom">Custom (1-100)</option>
          </select>
          <input type="number" id="customCount" min="1" max="100" placeholder="25" aria-label="Custom question count" disabled />
        </div>
      </div>

      <div class="form-field reviewer-actions">
        <button id="generateBtn" type="button">
          <i class="fas fa-brain"></i>&nbsp;Generate reviewer
        </button>
        <button id="resetBtn" type="button" class="ghost-button">
          <i class="fas fa-rotate"></i>&nbsp;Reset
        </button>
      </div>
    </section>

    <div class="advisor-status reviewer-status" id="statusBox" role="status" aria-live="polite">
      <strong><i class="fas fa-info-circle"></i>&nbsp;Waiting for a topic</strong>
      <p>Describe the subject you want to review and choose how many entries to generate.</p>
    </div>

    <section class="reviewer-output" id="reviewerSection" hidden aria-label="Reviewer cards">
      <div class="section-heading">
        <h2><i class="fas fa-book"></i>&nbsp;Reviewer</h2>
        <p>Scan these concise definitions before testing yourself.</p>
      </div>
      <div class="reviewer-cards" id="reviewerList"></div>
      <div class="reviewer-cta" id="quizCta" hidden>
        <div>
          <p class="quiz-topic" id="quizTopicLabel"></p>
          <p class="quiz-count" id="quizCountLabel"></p>
          <p>Ready to test your recall? Launch the quiz to get randomized multiple-choice questions.</p>
        </div>
        <button id="takeQuizBtn" type="button">
          <i class="fas fa-question-circle"></i>&nbsp;Take the quiz
        </button>
      </div>
    </section>

    <section class="advisor-notes" aria-label="Gemini API instructions">
      <h2><i class="fas fa-key"></i>&nbsp;API setup</h2>
      <ul>
        <li>Set your Google Gemini API key inside the <code>GEMINI_API_KEY</code> constant in this page.</li>
        <li>The key only lives in your browser and is used directly for each request.</li>
        <li>AI answers may be inaccurate—verify critical facts before memorizing.</li>
      </ul>
    </section>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha512-1+TpoA3nk9/J1GhFp1cV+LDVOGBev5nYeD1yfknhk+aoCA8DmF5asJ5AZt0pOEtpJR/YWZLxE+nobVhtSGcVw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    // Wait for PDF.js to load before initializing
    window.addEventListener('DOMContentLoaded', () => {
      if (window.pdfjsLib) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    });

    (() => {
      const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';
      const GEMINI_API_KEY = 'AIzaSyAi9o1H0rBWqafr5k3op4_iKEn5q80c2Rc'; // TODO: Replace with your Gemini API key.

      const topicInput = document.getElementById('topicInput');
      const questionPreset = document.getElementById('questionPreset');
      const customCountInput = document.getElementById('customCount');
      const pdfInput = document.getElementById('pdfInput');
      const pdfStatus = document.getElementById('pdfStatus');
      const pdfStatusText = document.getElementById('pdfStatusText');
      const pdfMetaText = document.getElementById('pdfMetaText');
      const pdfOptions = document.getElementById('pdfOptions');
      const includePdfToggle = document.getElementById('includePdfToggle');
      const clearPdfBtn = document.getElementById('clearPdfBtn');
      const generateBtn = document.getElementById('generateBtn');
      const resetBtn = document.getElementById('resetBtn');
      const statusBox = document.getElementById('statusBox');
      const reviewerSection = document.getElementById('reviewerSection');
      const reviewerList = document.getElementById('reviewerList');
      const quizCta = document.getElementById('quizCta');
      const takeQuizBtn = document.getElementById('takeQuizBtn');
      const quizTopicLabel = document.getElementById('quizTopicLabel');
      const quizCountLabel = document.getElementById('quizCountLabel');

      const STORAGE_KEY = 'reviewerQuizData';
      const PDF_SIZE_LIMIT = 10 * 1024 * 1024; // 10 MB
      const PDF_SNIPPET_CHARS = 8000;

      const state = {
        reviewerEntries: [],
        quizItems: [],
        topic: '',
        questionCount: 0,
        pdfText: '',
        pdfMeta: null,
      };

      /**
       * Updates the status ribbon tone + message.
       * @param {string} message
       * @param {'info'|'success'|'error'} tone
       */
      const updateStatus = (message, tone = 'info') => {
        statusBox.dataset.tone = tone;
        const toneIcon = tone === 'success' ? 'fa-circle-check' : tone === 'error' ? 'fa-triangle-exclamation' : 'fa-info-circle';
        const toneLabel = tone === 'success' ? 'Ready' : tone === 'error' ? 'Issue detected' : 'Working';
        statusBox.querySelector('strong').innerHTML = `<i class="fas ${toneIcon}"></i>&nbsp;${toneLabel}`;
        statusBox.querySelector('p').textContent = message;
      };

      const sanitizeText = (text) => (text || '').replace(/\s+/g, ' ').trim();

      const formatFileSize = (bytes) => `${(bytes / (1024 * 1024)).toFixed(2)} MB`;

      const setPdfStatus = (message, { meta = '', tone = 'info', show = true } = {}) => {
        if (!show) {
          pdfStatus.hidden = true;
          pdfStatusText.textContent = '';
          pdfMetaText.textContent = '';
          return;
        }
        pdfStatus.hidden = false;
        pdfStatus.dataset.tone = tone;
        pdfStatusText.textContent = message;
        if (meta) {
          pdfMetaText.hidden = false;
          pdfMetaText.textContent = meta;
        } else {
          pdfMetaText.hidden = true;
          pdfMetaText.textContent = '';
        }
      };

      const clearPdfSelection = (clearInput = true) => {
        if (clearInput) {
          pdfInput.value = '';
        }
        state.pdfText = '';
        state.pdfMeta = null;
        includePdfToggle.checked = true;
        includePdfToggle.disabled = true;
        pdfOptions.hidden = true;
        setPdfStatus('', { show: false });
      };

      const extractPdfText = async (file) => {
        if (!window.pdfjsLib) {
          throw new Error('PDF.js library is not loaded. Please refresh the page and try again.');
        }
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let combined = '';
        for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber += 1) {
          const page = await pdf.getPage(pageNumber);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map((item) => item.str).join(' ');
          combined += ` ${pageText}`;
          if (combined.length >= PDF_SNIPPET_CHARS) {
            break;
          }
        }
        const snippet = sanitizeText(combined).slice(0, PDF_SNIPPET_CHARS);
        return { text: snippet, pages: pdf.numPages };
      };

      const handlePdfChange = async () => {
        const file = pdfInput.files?.[0];
        if (!file) {
          clearPdfSelection(false);
          return;
        }
        if (file.size > PDF_SIZE_LIMIT) {
          clearPdfSelection(false);
          setPdfStatus('PDF exceeds the 10 MB limit. Please choose a smaller file.', { tone: 'error' });
          pdfStatus.hidden = false;
          return;
        }

        setPdfStatus('Extracting text from PDF…', { tone: 'info' });
        try {
          const { text, pages } = await extractPdfText(file);
          if (!text) {
            throw new Error('No extractable text found in the PDF.');
          }
          state.pdfText = text;
          state.pdfMeta = { name: file.name, pages, size: file.size };
          includePdfToggle.disabled = false;
          includePdfToggle.checked = true;
          pdfOptions.hidden = false;
          setPdfStatus('PDF ready. We will include key snippets unless you disable it below.', {
            meta: `${file.name} • ${pages} page(s) • ${formatFileSize(file.size)}`,
            tone: 'info',
          });
        } catch (error) {
          console.error('Failed to read PDF', error);
          clearPdfSelection(false);
          setPdfStatus(error.message || 'Unable to read PDF contents.', { tone: 'error' });
        }
      };

      const toggleCustomCount = () => {
        const isCustom = questionPreset.value === 'custom';
        customCountInput.disabled = !isCustom;
        customCountInput.setAttribute('aria-hidden', String(!isCustom));
        if (!isCustom) {
          customCountInput.value = '';
        } else {
          customCountInput.focus();
        }
      };

      /**
       * Resolves the requested question total.
       * @returns {number}
       */
      const getQuestionCount = () => {
        if (questionPreset.value !== 'custom') {
          return Number(questionPreset.value);
        }
        const customValue = Number(customCountInput.value);
        if (!Number.isInteger(customValue)) {
          throw new Error('Enter a whole number between 1 and 100.');
        }
        if (customValue < 1 || customValue > 100) {
          throw new Error('Custom question counts must stay between 1 and 100.');
        }
        return customValue;
      };

      /**
       * Builds the Gemini prompt.
       * @param {string} topic
       * @param {number} count
       * @returns {string}
       */
      const buildPrompt = (topic, count, pdfSnippet) => {
        const topicDirective = topic ? `Study request: ${topic}.` : 'Study request: derive the most important takeaways from the provided reference.';
        const referenceBlock = pdfSnippet
          ? `Reference excerpt (keep confidential, summarize it for the learner):
"""
${pdfSnippet}
"""`
          : 'No reference excerpt uploaded — rely on the study request alone.';

        return `You are an expert study coach. ${topicDirective}
${referenceBlock}
Return ONLY a JSON object inside one fenced code block using this schema:
{
  "reviewerEntries": [
    { "term": "", "definition": "", "keyTakeaway": "", "memoryHook": "" }
  ],
  "quizItems": [
    { "question": "", "choices": [""], "answerIndex": 0, "answerExplanation": "" }
  ]
}
Guidelines:
- Provide exactly ${count} reviewerEntries and ${count} quizItems.
- Definitions must stay under 60 words, plain English, still mention critical domain jargon.
- Each quiz question needs 4 concise, distinct choices. answerIndex is the zero-based correct choice.
- Use neutral, factual tone. Avoid markdown, LaTeX, or stray commentary.`;
      };

      /**
       * Calls Gemini and returns structured data.
       * @param {string} topic
       * @param {number} count
       * @param {string} apiKey
       * @returns {Promise<{ reviewerEntries: any[]; quizItems: any[]; }>}
       */
      const requestGeminiReviewer = async (topic, count, pdfSnippet, apiKey) => {
        const response = await fetch(`${API_URL}?key=${encodeURIComponent(apiKey)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [
              {
                role: 'user',
                parts: [{ text: buildPrompt(topic, count, pdfSnippet) }],
              },
            ],
            safetySettings: [
              { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
              { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            ],
          }),
        });

        if (!response.ok) {
          const detail = await response.text();
          throw new Error(`Gemini API error: ${response.status} ${detail}`);
        }

        const data = await response.json();
        const textResult = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!textResult) {
          throw new Error('Gemini response was empty.');
        }
        return parseReviewerPayload(textResult);
      };

      /**
       * Extracts JSON payload from Gemini text output.
       * @param {string} text
       */
      const parseReviewerPayload = (text) => {
        const match = text.match(/```json\s*([\s\S]*?)```/i) || text.match(/```\s*([\s\S]*?)```/i);
        if (!match) {
          throw new Error('Gemini response missing JSON block.');
        }
        const payload = JSON.parse(match[1]);
        if (!Array.isArray(payload.reviewerEntries) || payload.reviewerEntries.length === 0) {
          throw new Error('Reviewer entries missing from Gemini response.');
        }
        if (!Array.isArray(payload.quizItems) || payload.quizItems.length === 0) {
          throw new Error('Quiz items missing from Gemini response.');
        }
        return payload;
      };

      const setQuizMetaLabels = () => {
        if (state.topic) {
          quizTopicLabel.textContent = `Topic: ${state.topic}`;
          quizTopicLabel.hidden = false;
        } else {
          quizTopicLabel.textContent = '';
          quizTopicLabel.hidden = true;
        }

        if (state.questionCount) {
          quizCountLabel.textContent = `Questions prepared: ${state.questionCount}`;
          quizCountLabel.hidden = false;
        } else {
          quizCountLabel.textContent = '';
          quizCountLabel.hidden = true;
        }
      };

      /**
       * Renders reviewer cards.
       * @param {{ term: string; definition: string; keyTakeaway?: string; memoryHook?: string; }[]} entries
       * @param {{ focusButton?: boolean }} options
       */
      const renderReviewer = (entries, { focusButton = true } = {}) => {
        const cards = entries.map((entry, index) => {
          const title = entry.term || `Item ${index + 1}`;
          const definition = entry.definition || 'Definition unavailable.';
          const keyTakeaway = entry.keyTakeaway ? `<p class="takeaway"><strong>Key takeaway:</strong> ${entry.keyTakeaway}</p>` : '';
          const memoryHook = entry.memoryHook ? `<p class="memory"><strong>Memory hook:</strong> ${entry.memoryHook}</p>` : '';
          return `<article class="review-card">
            <h3>${title}</h3>
            <p>${definition}</p>
            ${keyTakeaway}
            ${memoryHook}
          </article>`;
        });
        reviewerList.innerHTML = cards.join('');
        reviewerSection.hidden = false;
        quizCta.hidden = false;
        setQuizMetaLabels();
        if (focusButton) {
          takeQuizBtn.focus();
        }
      };

      const hydrateFromStorage = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        try {
          const saved = JSON.parse(raw);
          if (!Array.isArray(saved.reviewerEntries) || !saved.reviewerEntries.length || !Array.isArray(saved.quizItems) || !saved.quizItems.length) {
            localStorage.removeItem(STORAGE_KEY);
            return;
          }
          state.reviewerEntries = saved.reviewerEntries;
          state.quizItems = saved.quizItems;
          state.topic = saved.topic || 'Custom topic';
          state.questionCount = Number(saved.questionCount) || saved.quizItems.length;
          renderReviewer(saved.reviewerEntries, { focusButton: false });
          updateStatus('Loaded your last reviewer. You can regenerate anytime.', 'info');
        } catch (error) {
          console.error('Failed to hydrate reviewer data', error);
          localStorage.removeItem(STORAGE_KEY);
        }
      };

      questionPreset.addEventListener('change', toggleCustomCount);
      hydrateFromStorage();

      generateBtn.addEventListener('click', async () => {
        const typedTopic = topicInput.value.trim();
        const pdfSnippet = includePdfToggle.checked && state.pdfText ? state.pdfText : '';
        if (!typedTopic && !pdfSnippet) {
          updateStatus('Describe a topic or attach a PDF before generating.', 'error');
          return;
        }
        if (!GEMINI_API_KEY?.trim()) {
          updateStatus('Set your Gemini API key inside GEMINI_API_KEY before continuing.', 'error');
          return;
        }

        let questionCount;
        try {
          questionCount = getQuestionCount();
        } catch (error) {
          updateStatus(error.message, 'error');
          return;
        }

        updateStatus('Contacting Gemini to craft your reviewer...', 'info');
        generateBtn.disabled = true;
        resetBtn.disabled = true;

        try {
          const payload = await requestGeminiReviewer(typedTopic, questionCount, pdfSnippet, GEMINI_API_KEY);
          state.reviewerEntries = payload.reviewerEntries;
          state.quizItems = payload.quizItems;
          state.topic = typedTopic || (state.pdfMeta ? `Notes from ${state.pdfMeta.name}` : 'Custom topic');
          state.questionCount = questionCount;
          renderReviewer(payload.reviewerEntries);
          localStorage.setItem(STORAGE_KEY, JSON.stringify({
            topic: state.topic,
            generatedAt: new Date().toISOString(),
            questionCount,
            reviewerEntries: payload.reviewerEntries,
            quizItems: payload.quizItems,
          }));
          updateStatus('Reviewer and quiz ready. Study first, then take the quiz!', 'success');
          reviewerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } catch (error) {
          console.error(error);
          updateStatus(error.message, 'error');
        } finally {
          generateBtn.disabled = false;
          resetBtn.disabled = false;
        }
      });

      resetBtn.addEventListener('click', () => {
        topicInput.value = '';
        questionPreset.value = '10';
        toggleCustomCount();
        clearPdfSelection();
        reviewerSection.hidden = true;
        reviewerList.innerHTML = '';
        quizCta.hidden = true;
        state.reviewerEntries = [];
        state.quizItems = [];
        state.topic = '';
        state.questionCount = 0;
        setQuizMetaLabels();
        localStorage.removeItem(STORAGE_KEY);
        updateStatus('Cleared inputs. Describe a fresh topic to begin again.', 'info');
      });

      takeQuizBtn.addEventListener('click', () => {
        if (!state.quizItems.length) {
          updateStatus('Generate a reviewer first so the quiz has data to work with.', 'error');
          return;
        }
        window.location.href = 'reviewer-quiz.html';
      });

      pdfInput.addEventListener('change', handlePdfChange);
      clearPdfBtn.addEventListener('click', () => {
        clearPdfSelection();
        setPdfStatus('Removed the PDF. Only your typed topic will be sent to Gemini.', { tone: 'info', show: true });
      });
      includePdfToggle.addEventListener('change', () => {
        if (!state.pdfText && includePdfToggle.checked) {
          includePdfToggle.checked = false;
        }
      });
    })();
  </script>
</body>
</html>
