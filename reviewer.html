<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reviewer</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
</head>
<body class="apps-page reviewer-page">
  <a href="apps.html" class="apps-button back-button">Apps</a>

  <div class="container reviewer-container">
    <h1>Reviewer</h1>
    <p class="apps-intro reviewer-intro">
      Drop in your lecture PDF or type a topic, then let Gemini craft concise reviewer cards plus a randomized quiz.
    </p>

    <section class="reviewer-form" role="form" aria-label="Generate AI reviewer">
      <div class="form-field">
        <label for="topicInput">What do you want to study?</label>
        <p class="field-hint">Optional when a PDF is attached—Gemini will prioritize the document.</p>
        <textarea id="topicInput" rows="3" placeholder="Describe a topic or leave blank when uploading a PDF"></textarea>
      </div>

      <div class="form-field">
        <label for="pdfInput">Attach a PDF (optional)</label>
        <p class="field-hint">Upload lecture notes, reviewers, or any PDF under 10&nbsp;MB. We'll extract the text locally and include the highlights in your prompt.</p>
        <div class="pdf-upload-wrapper" id="pdfInputWrapper" data-tone="idle">
          <input id="pdfInput" type="file" accept="application/pdf" />
          <button type="button" id="clearPdfBtn" class="ghost-button btn-compact" hidden>Remove PDF</button>
        </div>
        <p class="field-hint pdf-helper" id="pdfStatusText">No PDF attached yet. We'll lean on your typed topic.</p>
        <p class="field-hint pdf-helper" id="pdfMetaText" hidden></p>
      </div>

      <div class="form-field generation-options">
        <p class="field-hint">Tune how many cards we create and how the quiz should behave before generating.</p>
        <div class="generation-options-grid">
          <div class="option-card">
            <label for="questionPreset">How many questions?</label>
            <div class="count-control">
              <select id="questionPreset">
                <option value="10">10 questions</option>
                <option value="20">20 questions</option>
                <option value="30">30 questions</option>
                <option value="40">40 questions</option>
                <option value="50">50 questions</option>
                <option value="custom">Custom (1-100)</option>
              </select>
              <input type="number" id="customCount" min="1" max="100" placeholder="25" aria-label="Custom question count" disabled />
            </div>
          </div>
          <div class="option-card">
            <label for="questionFormat">Quiz format</label>
            <p class="field-hint">Pick how you want the quiz to behave when testing later on.</p>
            <select id="questionFormat">
              <option value="multiple-choice">Multiple choice (4 options)</option>
              <option value="identification">Identification (typed answer)</option>
            </select>
          </div>
        </div>
        <div class="reviewer-actions generation-actions">
          <button id="generateBtn" type="button">
            <i class="fas fa-brain"></i>&nbsp;Generate reviewer
          </button>
          <button id="resetBtn" type="button" class="ghost-button">
            <i class="fas fa-rotate"></i>&nbsp;Reset
          </button>
        </div>
      </div>
    </section>

    <div class="advisor-status reviewer-status" id="statusBox" role="status" aria-live="polite">
      <strong><i class="fas fa-info-circle"></i>&nbsp;Waiting for a topic</strong>
      <p>Describe the subject you want to review and choose how many entries to generate.</p>
    </div>

    <section class="reviewer-output" id="reviewerSection" hidden aria-label="Reviewer cards">
      <div class="section-heading">
        <h2><i class="fas fa-book"></i>&nbsp;Reviewer</h2>
        <p>Scan these concise definitions before testing yourself.</p>
      </div>
      <div class="reviewer-card-stage" id="reviewerCardContainer" hidden>
        <article class="review-card index-card" id="reviewerActiveCard" aria-live="polite"></article>
        <div class="reviewer-card-controls">
          <p class="card-progress" id="reviewerCardPosition">Card 0 of 0</p>
          <div class="card-nav">
            <button type="button" class="ghost-button btn-compact" id="prevReviewerBtn" aria-label="Previous reviewer card">
              <i class="fas fa-arrow-left"></i>
              <span>Previous</span>
            </button>
            <button type="button" class="ghost-button btn-compact" id="nextReviewerBtn" aria-label="Next reviewer card">
              <span>Next</span>
              <i class="fas fa-arrow-right"></i>
            </button>
          </div>
        </div>
      </div>
      <div class="reviewer-cta" id="quizCta" hidden>
        <div>
          <p class="quiz-topic" id="quizTopicLabel"></p>
          <p class="quiz-count" id="quizCountLabel"></p>
          <p class="quiz-format" id="quizFormatLabel"></p>
          <p>Ready to test your recall? Launch the quiz to get randomized questions in your selected format.</p>
        </div>
        <button id="takeQuizBtn" type="button">
          <i class="fas fa-question-circle"></i>&nbsp;Take the quiz
        </button>
      </div>
    </section>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    window.addEventListener('load', () => {
      if (!window.pdfjsLib) {
        console.error('PDF.js failed to load. Please check the CDN URL.');
        return;
      }

      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

      (() => {
      const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';
      const GEMINI_API_KEY = 'AIzaSyAi9o1H0rBWqafr5k3op4_iKEn5q80c2Rc'; // TODO: Replace with your Gemini API key.

      const topicInput = document.getElementById('topicInput');
      const questionPreset = document.getElementById('questionPreset');
      const customCountInput = document.getElementById('customCount');
      const questionFormatSelect = document.getElementById('questionFormat');
      const pdfInput = document.getElementById('pdfInput');
      const pdfInputWrapper = document.getElementById('pdfInputWrapper');
      const pdfStatusText = document.getElementById('pdfStatusText');
      const pdfMetaText = document.getElementById('pdfMetaText');
      const clearPdfBtn = document.getElementById('clearPdfBtn');
      const generateBtn = document.getElementById('generateBtn');
      const resetBtn = document.getElementById('resetBtn');
      const statusBox = document.getElementById('statusBox');
      const reviewerSection = document.getElementById('reviewerSection');
      const reviewerCardContainer = document.getElementById('reviewerCardContainer');
      const reviewerActiveCard = document.getElementById('reviewerActiveCard');
      const reviewerCardPosition = document.getElementById('reviewerCardPosition');
      const prevReviewerBtn = document.getElementById('prevReviewerBtn');
      const nextReviewerBtn = document.getElementById('nextReviewerBtn');
      const quizCta = document.getElementById('quizCta');
      const takeQuizBtn = document.getElementById('takeQuizBtn');
      const quizTopicLabel = document.getElementById('quizTopicLabel');
      const quizCountLabel = document.getElementById('quizCountLabel');
      const quizFormatLabel = document.getElementById('quizFormatLabel');

      const STORAGE_KEY = 'reviewerQuizData';
      const PDF_SIZE_LIMIT = 10 * 1024 * 1024; // 10 MB
      const PDF_SNIPPET_CHARS = 8000;
      const DEFAULT_PDF_HINT = 'No PDF attached yet. We\'ll lean on your typed topic.';

      const state = {
        reviewerEntries: [],
        quizItems: [],
        topic: '',
        questionCount: 0,
        questionFormat: 'multiple-choice',
        pdfText: '',
        pdfMeta: null,
        usePdf: false,
        currentCardIndex: 0,
      };

      setPdfStatus(DEFAULT_PDF_HINT, { tone: 'idle', hasFile: false });

      /**
       * Updates the status ribbon tone + message.
       * @param {string} message
       * @param {'info'|'success'|'error'} tone
       */
      const updateStatus = (message, tone = 'info') => {
        statusBox.dataset.tone = tone;
        const toneIcon = tone === 'success' ? 'fa-circle-check' : tone === 'error' ? 'fa-triangle-exclamation' : 'fa-info-circle';
        const toneLabel = tone === 'success' ? 'Ready' : tone === 'error' ? 'Issue detected' : 'Working';
        statusBox.querySelector('strong').innerHTML = `<i class="fas ${toneIcon}"></i>&nbsp;${toneLabel}`;
        statusBox.querySelector('p').textContent = message;
      };

      const sanitizeText = (text) => (text || '').replace(/\s+/g, ' ').trim();

      const formatFileSize = (bytes) => `${(bytes / (1024 * 1024)).toFixed(2)} MB`;

      const setPdfStatus = (message = DEFAULT_PDF_HINT, { meta = '', tone = 'info', hasFile = false } = {}) => {
        if (!pdfInputWrapper) return;
        pdfInputWrapper.dataset.tone = tone;
        pdfInputWrapper.classList.toggle('has-file', hasFile);
        if (pdfStatusText) {
          pdfStatusText.textContent = message || DEFAULT_PDF_HINT;
        }
        if (pdfMetaText) {
          if (meta) {
            pdfMetaText.hidden = false;
            pdfMetaText.textContent = meta;
          } else {
            pdfMetaText.hidden = true;
            pdfMetaText.textContent = '';
          }
        }
        if (clearPdfBtn) {
          clearPdfBtn.hidden = !hasFile;
        }
      };

      const clearPdfSelection = (clearInput = true) => {
        if (clearInput) {
          pdfInput.value = '';
        }
        state.pdfText = '';
        state.pdfMeta = null;
        state.usePdf = false;
        setPdfStatus(DEFAULT_PDF_HINT, { tone: 'idle', hasFile: false });
      };

      const extractPdfText = async (file) => {
        if (!window.pdfjsLib) {
          throw new Error('PDF.js library is not loaded. Please refresh the page and try again.');
        }
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let combined = '';
        for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber += 1) {
          const page = await pdf.getPage(pageNumber);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map((item) => item.str).join(' ');
          combined += ` ${pageText}`;
          if (combined.length >= PDF_SNIPPET_CHARS) {
            break;
          }
        }
        const snippet = sanitizeText(combined).slice(0, PDF_SNIPPET_CHARS);
        return { text: snippet, pages: pdf.numPages };
      };

      const handlePdfChange = async () => {
        const file = pdfInput.files?.[0];
        if (!file) {
          clearPdfSelection(false);
          return;
        }
        if (file.size > PDF_SIZE_LIMIT) {
          clearPdfSelection(false);
          setPdfStatus('PDF exceeds the 10 MB limit. Please choose a smaller file.', { tone: 'error', hasFile: false });
          return;
        }

        setPdfStatus('Extracting text from PDF…', { tone: 'info', hasFile: false });
        try {
          const { text, pages } = await extractPdfText(file);
          if (!text) {
            throw new Error('No extractable text found in the PDF.');
          }
          state.pdfText = text;
          state.pdfMeta = { name: file.name, pages, size: file.size };
          state.usePdf = true;
          setPdfStatus('PDF ready. We will include key snippets unless you remove it.', {
            meta: `${file.name} • ${pages} page(s) • ${formatFileSize(file.size)}`,
            tone: 'success',
            hasFile: true,
          });
        } catch (error) {
          console.error('Failed to read PDF', error);
          clearPdfSelection(false);
          setPdfStatus(error.message || 'Unable to read PDF contents.', { tone: 'error', hasFile: false });
        }
      };

      const toggleCustomCount = () => {
        const isCustom = questionPreset.value === 'custom';
        customCountInput.disabled = !isCustom;
        customCountInput.setAttribute('aria-hidden', String(!isCustom));
        if (!isCustom) {
          customCountInput.value = '';
        } else {
          customCountInput.focus();
        }
      };

      /**
       * Resolves the requested question total.
       * @returns {number}
       */
      const getQuestionCount = () => {
        if (questionPreset.value !== 'custom') {
          return Number(questionPreset.value);
        }
        const customValue = Number(customCountInput.value);
        if (!Number.isInteger(customValue)) {
          throw new Error('Enter a whole number between 1 and 100.');
        }
        if (customValue < 1 || customValue > 100) {
          throw new Error('Custom question counts must stay between 1 and 100.');
        }
        return customValue;
      };

      /**
       * Builds the Gemini prompt.
       * @param {string} topic
       * @param {number} count
       * @returns {string}
       */
      const buildPrompt = (topic, count, pdfSnippet, format) => {
        const topicDirective = topic ? `Study request: ${topic}.` : 'Study request: derive the most important takeaways from the provided reference.';
        const referenceBlock = pdfSnippet
          ? `Reference excerpt (keep confidential, summarize it for the learner):
"""
${pdfSnippet}
"""`
          : 'No reference excerpt uploaded — rely on the study request alone.';
        const formatDirective = format === 'identification'
          ? `Quiz style: identification / short-answer. For every quizItems entry, include "questionType": "identification" and an "answerText" string containing the expected response. Do not return "choices" or "answerIndex" for this mode.`
          : `Quiz style: multiple choice. Each quizItems entry must include "questionType": "multiple-choice", four concise "choices", and "answerIndex" pointing to the correct option.`;

        return `You are an expert study coach. ${topicDirective}
${referenceBlock}
${formatDirective}
Return ONLY a JSON object inside one fenced code block using this schema:
{
  "reviewerEntries": [
    { "term": "", "definition": "", "keyTakeaway": "", "memoryHook": "" }
  ],
  "quizItems": [
    { "question": "", "questionType": "", "choices": [""], "answerIndex": 0, "answerExplanation": "", "answerText": "" }
  ]
}
Guidelines:
- Provide exactly ${count} reviewerEntries and ${count} quizItems.
- Definitions must stay under 60 words, plain English, still mention critical domain jargon.
- When in multiple-choice mode, supply 4 concise, distinct choices and set answerIndex to the zero-based correct choice.
- When in identification mode, skip choices entirely and respond with an informative answerText worth 3-6 words.
- Use neutral, factual tone. Avoid markdown, LaTeX, or stray commentary.`;
      };

      /**
       * Calls Gemini and returns structured data.
       * @param {string} topic
       * @param {number} count
       * @param {string} apiKey
       * @returns {Promise<{ reviewerEntries: any[]; quizItems: any[]; }>}
       */
      const requestGeminiReviewer = async (topic, count, pdfSnippet, format, apiKey) => {
        const response = await fetch(`${API_URL}?key=${encodeURIComponent(apiKey)}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [
              {
                role: 'user',
                parts: [{ text: buildPrompt(topic, count, pdfSnippet, format) }],
              },
            ],
            safetySettings: [
              { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
              { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            ],
          }),
        });

        if (!response.ok) {
          const detail = await response.text();
          throw new Error(`Gemini API error: ${response.status} ${detail}`);
        }

        const data = await response.json();
        const textResult = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!textResult) {
          throw new Error('Gemini response was empty.');
        }
        return parseReviewerPayload(textResult);
      };

      /**
       * Extracts JSON payload from Gemini text output.
       * @param {string} text
       */
      const parseReviewerPayload = (text) => {
        const match = text.match(/```json\s*([\s\S]*?)```/i) || text.match(/```\s*([\s\S]*?)```/i);
        if (!match) {
          throw new Error('Gemini response missing JSON block.');
        }
        const payload = JSON.parse(match[1]);
        if (!Array.isArray(payload.reviewerEntries) || payload.reviewerEntries.length === 0) {
          throw new Error('Reviewer entries missing from Gemini response.');
        }
        if (!Array.isArray(payload.quizItems) || payload.quizItems.length === 0) {
          throw new Error('Quiz items missing from Gemini response.');
        }
        return payload;
      };

      const setQuizMetaLabels = () => {
        if (state.topic) {
          quizTopicLabel.textContent = `Topic: ${state.topic}`;
          quizTopicLabel.hidden = false;
        } else {
          quizTopicLabel.textContent = '';
          quizTopicLabel.hidden = true;
        }

        if (state.questionCount) {
          quizCountLabel.textContent = `Questions prepared: ${state.questionCount}`;
          quizCountLabel.hidden = false;
        } else {
          quizCountLabel.textContent = '';
          quizCountLabel.hidden = true;
        }

        if (state.questionFormat === 'identification') {
          quizFormatLabel.textContent = 'Format: Identification (typed answer)';
          quizFormatLabel.hidden = false;
        } else if (state.questionFormat === 'multiple-choice') {
          quizFormatLabel.textContent = 'Format: Multiple choice';
          quizFormatLabel.hidden = false;
        } else {
          quizFormatLabel.textContent = '';
          quizFormatLabel.hidden = true;
        }
      };

      const buildCardMarkup = (entry, index) => {
        const title = entry.term || `Item ${index + 1}`;
        const definition = entry.definition || 'Definition unavailable.';
        const keyTakeaway = entry.keyTakeaway ? `<p class="takeaway"><strong>Key takeaway:</strong> ${entry.keyTakeaway}</p>` : '';
        const memoryHook = entry.memoryHook ? `<p class="memory"><strong>Memory hook:</strong> ${entry.memoryHook}</p>` : '';
        return `<div class="card-header">
            <p class="card-index">${index + 1}</p>
            <h3>${title}</h3>
          </div>
          <p>${definition}</p>
          ${keyTakeaway}
          ${memoryHook}`;
      };

      const updateCardControls = () => {
        const total = state.reviewerEntries.length;
        const { currentCardIndex } = state;
        reviewerCardPosition.textContent = `Card ${total ? currentCardIndex + 1 : 0} of ${total}`;
        prevReviewerBtn.disabled = currentCardIndex <= 0;
        nextReviewerBtn.disabled = total === 0 || currentCardIndex >= total - 1;
      };

      const showReviewerCard = (index) => {
        const total = state.reviewerEntries.length;
        if (!total) {
          reviewerActiveCard.innerHTML = '<p>No reviewer cards yet. Generate one to start studying.</p>';
          reviewerCardContainer.hidden = true;
          updateCardControls();
          return;
        }
        const nextIndex = Math.min(Math.max(index, 0), total - 1);
        state.currentCardIndex = nextIndex;
        reviewerActiveCard.innerHTML = buildCardMarkup(state.reviewerEntries[nextIndex], nextIndex);
        reviewerCardContainer.hidden = false;
        updateCardControls();
      };

      /**
       * Renders reviewer cards as an index-card slider.
       * @param {{ term: string; definition: string; keyTakeaway?: string; memoryHook?: string; }[]} entries
       * @param {{ focusButton?: boolean }} options
       */
      const renderReviewer = (entries, { focusButton = true } = {}) => {
        state.currentCardIndex = 0;
        reviewerSection.hidden = false;
        quizCta.hidden = false;
        showReviewerCard(0);
        setQuizMetaLabels();
        if (focusButton) {
          takeQuizBtn.focus();
        }
      };

      const hydrateFromStorage = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        try {
          const saved = JSON.parse(raw);
          if (!Array.isArray(saved.reviewerEntries) || !saved.reviewerEntries.length || !Array.isArray(saved.quizItems) || !saved.quizItems.length) {
            localStorage.removeItem(STORAGE_KEY);
            return;
          }
          state.reviewerEntries = saved.reviewerEntries;
          state.quizItems = saved.quizItems;
          state.topic = saved.topic || 'Custom topic';
          state.questionCount = Number(saved.questionCount) || saved.quizItems.length;
          state.questionFormat = saved.questionFormat || 'multiple-choice';
          questionFormatSelect.value = state.questionFormat;
          renderReviewer(saved.reviewerEntries, { focusButton: false });
          updateStatus('Loaded your last reviewer. You can regenerate anytime.', 'info');
        } catch (error) {
          console.error('Failed to hydrate reviewer data', error);
          localStorage.removeItem(STORAGE_KEY);
        }
      };

      questionPreset.addEventListener('change', toggleCustomCount);
      hydrateFromStorage();

      generateBtn.addEventListener('click', async () => {
        const typedTopic = topicInput.value.trim();
        const pdfSnippet = state.usePdf && state.pdfText ? state.pdfText : '';
        const selectedFormat = questionFormatSelect.value;
        if (!typedTopic && !pdfSnippet) {
          updateStatus('Type a topic or attach a PDF before generating.', 'error');
          return;
        }
        if (!GEMINI_API_KEY?.trim()) {
          updateStatus('Set your Gemini API key inside GEMINI_API_KEY before continuing.', 'error');
          return;
        }

        let questionCount;
        try {
          questionCount = getQuestionCount();
        } catch (error) {
          updateStatus(error.message, 'error');
          return;
        }

        const workingMessage = pdfSnippet
          ? 'Gemini is analyzing your PDF and building reviewer cards...'
          : 'Contacting Gemini to craft your reviewer...';
        updateStatus(workingMessage, 'info');
        generateBtn.disabled = true;
        resetBtn.disabled = true;

        try {
          const payload = await requestGeminiReviewer(typedTopic, questionCount, pdfSnippet, selectedFormat, GEMINI_API_KEY);
          state.reviewerEntries = payload.reviewerEntries;
          state.quizItems = payload.quizItems;
          state.topic = pdfSnippet
            ? state.pdfMeta
              ? `Notes from ${state.pdfMeta.name}`
              : 'PDF-based reviewer'
            : typedTopic || 'Custom topic';
          state.questionCount = questionCount;
          state.questionFormat = selectedFormat;
          renderReviewer(payload.reviewerEntries);
          localStorage.setItem(STORAGE_KEY, JSON.stringify({
            topic: state.topic,
            generatedAt: new Date().toISOString(),
            questionCount,
            questionFormat: selectedFormat,
            reviewerEntries: payload.reviewerEntries,
            quizItems: payload.quizItems,
          }));
          const successMessage = pdfSnippet
            ? 'PDF processed! Review the AI-generated cards, then take the quiz.'
            : 'Reviewer and quiz ready. Study first, then take the quiz!';
          updateStatus(successMessage, 'success');
          reviewerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } catch (error) {
          console.error(error);
          updateStatus(error.message, 'error');
        } finally {
          generateBtn.disabled = false;
          resetBtn.disabled = false;
        }
      });

      resetBtn.addEventListener('click', () => {
        topicInput.value = '';
        questionPreset.value = '10';
        toggleCustomCount();
        questionFormatSelect.value = 'multiple-choice';
        clearPdfSelection();
        reviewerSection.hidden = true;
        reviewerCardContainer.hidden = true;
        reviewerActiveCard.innerHTML = '';
        reviewerCardPosition.textContent = 'Card 0 of 0';
        quizCta.hidden = true;
        state.reviewerEntries = [];
        state.quizItems = [];
        state.currentCardIndex = 0;
        state.topic = '';
        state.questionCount = 0;
        state.questionFormat = 'multiple-choice';
        setQuizMetaLabels();
        localStorage.removeItem(STORAGE_KEY);
        updateStatus('Cleared inputs. Describe a fresh topic to begin again.', 'info');
      });

      prevReviewerBtn.addEventListener('click', () => {
        if (state.currentCardIndex > 0) {
          showReviewerCard(state.currentCardIndex - 1);
        }
      });

      nextReviewerBtn.addEventListener('click', () => {
        if (state.currentCardIndex < state.reviewerEntries.length - 1) {
          showReviewerCard(state.currentCardIndex + 1);
        }
      });

      takeQuizBtn.addEventListener('click', () => {
        if (!state.quizItems.length) {
          updateStatus('Generate a reviewer first so the quiz has data to work with.', 'error');
          return;
        }
        window.location.href = 'reviewer-quiz.html';
      });

      pdfInput.addEventListener('change', handlePdfChange);
      clearPdfBtn.addEventListener('click', () => {
        clearPdfSelection();
        setPdfStatus('Removed the PDF. Only your typed topic will be sent to Gemini.', { tone: 'info', hasFile: false });
      });
      })();
    });
  </script>
</body>
</html>
