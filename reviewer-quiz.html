<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reviewer Quiz</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
</head>
<body class="apps-page reviewer-quiz-page">
  <a href="apps.html" class="apps-button">Apps</a>
  <a href="reviewer.html" class="apps-button back-button">Reviewer</a>

  <div class="container reviewer-container">
    <h1>Quiz Session</h1>
    <p class="apps-intro">Answer the shuffled questions for your latest topic. When you finish, we will show your score and let you retake the quiz instantly.</p>

    <div class="quiz-status" id="statusBox" role="status" aria-live="polite">
      <strong><i class="fas fa-info-circle"></i>&nbsp;Loading</strong>
      <p>Fetching your reviewer dataâ€¦</p>
    </div>

    <section class="reviewer-quiz" id="quizSection" hidden aria-label="Quiz section">
      <div class="quiz-meta-bar">
        <div>Topic: <span id="topicLabel">â€”</span></div>
        <div>Questions prepared: <span id="countLabel">0</span></div>
        <div>Format: <span id="formatLabel">â€”</span></div>
        <div>Progress: <span id="progressLabel">0 / 0</span></div>
      </div>
      <div class="quiz-panel">
        <div class="quiz-question" id="questionText">Loadingâ€¦</div>
        <p class="quiz-mode-note" id="modeNote" hidden>Loading quiz modeâ€¦</p>
        <div class="quiz-choices" id="choicesList" role="group" aria-live="polite"></div>
        <div class="quiz-buttons">
          <button id="nextQuestionBtn" type="button" disabled>Next question</button>
        </div>
      </div>
    </section>

    <section class="quiz-results" id="resultsSection" hidden aria-label="Quiz results">
      <h3><i class="fas fa-award"></i>&nbsp;Score summary</h3>
      <p id="scoreLine">You scored 0 out of 0.</p>
      <p id="encouragementText"></p>
      <div class="quiz-buttons">
        <button id="retakeQuizBtn" type="button" disabled>Retake quiz</button>
        <button id="reviewCardsBtn" type="button" class="ghost-button">Review cards again</button>
      </div>
    </section>

  </div>

  <script>
    (() => {
      const STORAGE_KEY = 'reviewerQuizData';
      const statusBox = document.getElementById('statusBox');
      const quizSection = document.getElementById('quizSection');
      const resultsSection = document.getElementById('resultsSection');
      const emptyState = document.getElementById('emptyState');
      const topicLabel = document.getElementById('topicLabel');
      const countLabel = document.getElementById('countLabel');
      const formatLabel = document.getElementById('formatLabel');
      const progressLabel = document.getElementById('progressLabel');
      const questionText = document.getElementById('questionText');
      const modeNote = document.getElementById('modeNote');
      const choicesList = document.getElementById('choicesList');
      const nextQuestionBtn = document.getElementById('nextQuestionBtn');
      const retakeQuizBtn = document.getElementById('retakeQuizBtn');
      const reviewCardsBtn = document.getElementById('reviewCardsBtn');
      const scoreLine = document.getElementById('scoreLine');
      const encouragementText = document.getElementById('encouragementText');

      const state = {
        quizItems: [],
        order: [],
        index: 0,
        score: 0,
        userAnswers: [],
        topic: '',
        questionFormat: 'multiple-choice',
      };

      const FORMAT_NAMES = {
        'multiple-choice': 'Multiple choice',
        identification: 'Identification',
      };

      const inferQuestionFormat = (items = []) => (items.some((item) => (item.questionType || '').toLowerCase() === 'identification')
        ? 'identification'
        : 'multiple-choice');

      const normalizeAnswer = (value = '') => value
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9 ]+/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase();

      const splitAnswerText = (answerText = '') => answerText
        .split(/(?:,|\/|;|\bor\b)/i)
        .map((part) => part.trim())
        .filter(Boolean);

      const getAcceptedAnswers = (questionData = {}) => {
        const accepted = [];
        if (questionData.answerText) {
          accepted.push(...splitAnswerText(questionData.answerText));
        }
        if (Array.isArray(questionData.choices) && questionData.choices.length) {
          const correctChoice = questionData.choices[Number(questionData.answerIndex)];
          if (correctChoice) {
            accepted.push(correctChoice);
          }
        }
        return accepted;
      };

      const evaluateIdentificationAnswer = (inputValue, questionData) => {
        const normalizedUser = normalizeAnswer(inputValue);
        const acceptedAnswers = getAcceptedAnswers(questionData);
        const normalizedAccepted = acceptedAnswers.map((item) => normalizeAnswer(item));
        const isCorrect = normalizedUser.length > 0 && normalizedAccepted.includes(normalizedUser);
        return { isCorrect, acceptedAnswers };
      };

      const setFormatMeta = () => {
        const formatName = FORMAT_NAMES[state.questionFormat] || FORMAT_NAMES['multiple-choice'];
        formatLabel.textContent = formatName;
      };

      const setModeNote = (questionType) => {
        const normalizedType = (questionType || '').toLowerCase();
        const copy = normalizedType === 'identification'
          ? 'Type your answer and click Submit to move to the next question. Your answers will be checked at the end.'
          : normalizedType === 'multiple-choice'
            ? 'Select the best option, then click Next to continue. Your answers will be checked at the end.'
            : '';
        if (copy) {
          modeNote.textContent = copy;
          modeNote.hidden = false;
        } else {
          modeNote.textContent = '';
          modeNote.hidden = true;
        }
      };

      const handleIdentificationSubmission = (answerInput, submitBtn) => {
        const userValue = answerInput.value.trim();
        if (!userValue) return;
        answerInput.disabled = true;
        submitBtn.disabled = true;
        state.userAnswers[state.index] = userValue;
        
        // Move to next question automatically for identification
        state.index += 1;
        renderQuestion();
      };

      const renderIdentificationQuestion = (questionData) => {
        const acceptedAnswers = getAcceptedAnswers(questionData);
        if (!acceptedAnswers.length) {
          choicesList.innerHTML = '<p class="quiz-summary">This identification question is missing an answer key. Please regenerate your reviewer.</p>';
          nextQuestionBtn.disabled = false;
          nextQuestionBtn.hidden = false;
          return;
        }

        // Determine button text based on position in quiz
        const isLastQuestion = state.index === state.order.length - 1;
        const buttonText = isLastQuestion ? 'Submit & Finish' : 'Submit & Next';

        choicesList.innerHTML = `
          <div class="quiz-answer-input">
            <label class="sr-only" for="identificationInput">Type your answer</label>
            <input type="text" id="identificationInput" placeholder="Type your answer" autocomplete="off" />
            <button type="button" id="submitAnswerBtn" disabled>${buttonText}</button>
          </div>
        `;

        const answerInput = document.getElementById('identificationInput');
        const submitAnswerBtn = document.getElementById('submitAnswerBtn');
        answerInput.addEventListener('input', () => {
          submitAnswerBtn.disabled = !answerInput.value.trim();
        });
        submitAnswerBtn.addEventListener('click', () => handleIdentificationSubmission(answerInput, submitAnswerBtn));
      };

      const updateStatus = (message, tone = 'info', label = 'Status') => {
        statusBox.dataset.tone = tone;
        const toneIcon = tone === 'success' ? 'fa-circle-check' : tone === 'error' ? 'fa-triangle-exclamation' : 'fa-info-circle';
        statusBox.querySelector('strong').innerHTML = `<i class="fas ${toneIcon}"></i>&nbsp;${label}`;
        statusBox.querySelector('p').textContent = message;
      };

      const shuffle = (array) => {
        const copy = [...array];
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      };

      const hydrateQuiz = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          updateStatus('No reviewer data detected. Generate one first.', 'error', 'Missing data');
          quizSection.hidden = true;
          resultsSection.hidden = true;
          return false;
        }
        try {
          const payload = JSON.parse(raw);
          if (!Array.isArray(payload.quizItems) || !payload.quizItems.length) {
            throw new Error('Quiz items missing in saved payload.');
          }
          state.quizItems = payload.quizItems;
          state.topic = payload.topic || 'Custom topic';
          state.questionFormat = payload.questionFormat || inferQuestionFormat(payload.quizItems);
          topicLabel.textContent = state.topic;
          countLabel.textContent = payload.questionCount || payload.quizItems.length;
          setFormatMeta();
          quizSection.hidden = false;
          return true;
        } catch (error) {
          console.error('Failed to read quiz payload', error);
          updateStatus('Saved quiz data is corrupt. Please regenerate the reviewer.', 'error', 'Corrupted data');
          localStorage.removeItem(STORAGE_KEY);
          quizSection.hidden = true;
          resultsSection.hidden = true;
          return false;
        }
      };

      const renderQuestion = () => {
        if (state.index >= state.order.length) {
          finishQuiz();
          return;
        }
        const questionData = state.quizItems[state.order[state.index]];
        progressLabel.textContent = `${state.index + 1} / ${state.order.length}`;
        questionText.textContent = questionData.question || 'Question unavailable.';
        nextQuestionBtn.disabled = true;
        const questionType = (questionData.questionType || state.questionFormat || 'multiple-choice').toLowerCase();
        choicesList.classList.toggle('is-identification', questionType === 'identification');
        choicesList.setAttribute('role', questionType === 'multiple-choice' ? 'group' : 'presentation');
        setModeNote(questionType);

        if (questionType === 'identification') {
          // Hide next button for identification questions
          nextQuestionBtn.hidden = true;
          renderIdentificationQuestion(questionData);
        } else {
          // Show next button for multiple choice questions
          nextQuestionBtn.hidden = false;
          const choiceObjects = (questionData.choices || []).map((choice, idx) => ({
            text: choice,
            correct: idx === Number(questionData.answerIndex),
          })).filter((choice) => choice.text);

          if (!choiceObjects.length) {
            choicesList.innerHTML = '<p class="quiz-summary">Gemini did not return answer choices for this question.</p>';
            nextQuestionBtn.disabled = false;
            return;
          }

          const shuffledChoices = shuffle(choiceObjects);
          choicesList.innerHTML = shuffledChoices.map((choice, idx) => `
            <button type="button" class="choice-btn" data-correct="${choice.correct}" data-choice="${idx}">${choice.text}</button>
          `).join('');

          choicesList.querySelectorAll('.choice-btn').forEach((button) => {
            button.addEventListener('click', () => handleChoice(button));
          });
          
          nextQuestionBtn.textContent = state.index === state.order.length - 1 ? 'Finish quiz' : 'Next question';
        }
      };

      const handleChoice = (button) => {
        // Store the user's answer
        const isCorrect = button.dataset.correct === 'true';
        state.userAnswers[state.index] = isCorrect;
        
        // Disable all buttons and highlight selected
        choicesList.querySelectorAll('.choice-btn').forEach((choiceBtn) => {
          choiceBtn.disabled = true;
          if (choiceBtn === button) {
            choiceBtn.classList.add('choice-selected');
          }
        });

        nextQuestionBtn.disabled = false;
      };

      const finishQuiz = () => {
        // Calculate score from stored answers
        state.score = 0;
        state.userAnswers.forEach((answer, idx) => {
          const questionData = state.quizItems[state.order[idx]];
          const questionType = (questionData.questionType || state.questionFormat || 'multiple-choice').toLowerCase();
          
          if (questionType === 'identification') {
            const { isCorrect } = evaluateIdentificationAnswer(answer, questionData);
            if (isCorrect) state.score += 1;
          } else {
            // For multiple choice, answer is already a boolean
            if (answer === true) state.score += 1;
          }
        });

        const ratio = state.score / state.order.length;
        const percentage = Math.round(ratio * 100);
        
        // Show popup with results
        const encouragement = ratio === 1
          ? 'Perfect score! ðŸŽ‰'
          : ratio >= 0.7
            ? 'Great job! ðŸ‘'
            : 'Keep practicing! ðŸ’ª';
        
        alert(`Quiz Complete!\\n\\n${encouragement}\\n\\nYour Score: ${state.score} / ${state.order.length} (${percentage}%)`);
        
        // Show results section
        quizSection.hidden = true;
        resultsSection.hidden = false;
        setModeNote('');
        retakeQuizBtn.disabled = false;
        scoreLine.textContent = `You scored ${state.score} out of ${state.order.length} questions (${percentage}%).`;
        encouragementText.textContent = ratio === 1
          ? 'Perfect score! Try another topic or retake for practice.'
          : ratio >= 0.7
            ? 'Nice work. Review any tricky terms, then retake for mastery.'
            : 'Keep practicing. Revisit the reviewer cards, then retake the quiz for a fresh order.';
        updateStatus('Quiz complete! Review your score below.', 'success', 'Finished');
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };

      const startQuiz = () => {
        state.order = shuffle(Array.from({ length: state.quizItems.length }, (_, idx) => idx));
        state.index = 0;
        state.score = 0;
        state.userAnswers = [];
        progressLabel.textContent = `0 / ${state.order.length}`;
        quizSection.hidden = false;
        resultsSection.hidden = true;
        retakeQuizBtn.disabled = true;
        setFormatMeta();
        setModeNote(state.questionFormat);
        updateStatus('Quiz ready. Answer each question, then tap Next.', 'info', 'Ready');
        renderQuestion();
      };

      nextQuestionBtn.addEventListener('click', () => {
        if (state.index >= state.order.length) {
          finishQuiz();
          return;
        }
        state.index += 1;
        renderQuestion();
      });

      retakeQuizBtn.addEventListener('click', () => {
        startQuiz();
      });

      reviewCardsBtn.addEventListener('click', () => {
        window.location.href = 'reviewer.html';
      });

      if (hydrateQuiz()) {
        startQuiz();
      }
    })();
  </script>
</body>
</html>
